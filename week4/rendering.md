# レンダリング

## そもそもレンダリングとは？

React におけるレンダリングとは、現在の Props と State をもとに、React がコンポーネントに対して、どのように見えるか（表示されるか）を尋ねるプロセスです。

## レンダリングのフェーズ

react のレンダリングにはライフサイクルという順序に従って実行される各フェーズから構成されるものがあります。これについては、[こちらに優れた React のライフサイクルメソッド図](https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)があるので、参考にしてください。

ただし、ライフサイクルはクラスコンポーネントで使用するものであり、関数コンポーネントでは Hook を使用します。そのため、クラスコンポーネントの処理を理解する必要はありませんが、ライフサイクルフックにつけられている名前 componentDidMount などは useEffect とは異なり名前からどのような処理かイメージすることができるので useEffect の理解の助けにはなると思います。

## 再レンダリング

前回の State のサンプルプログラムでは、カウントアップをした時やフォームに文字を入力した時、画面をリロードしていないにも関わらず画面の表示が変更されたと思います。これはコンポーネントが `再レンダリング` されたからです。

このように、React では State が更新された時に関数コンポーネントは再び頭から処理が走り、差分がある DOM を検知し、変更を反映して画面を表示しています。この「変更を検知してコンポーネントを再処理すること」を `再レンダリング` と呼びます。

再レンダリングが起きるのは主に以下の3つのパターンがあります。

- State が更新されたコンポーネント
- Props が変更されたコンポーネント
- 再レンダリングされたコンポーネント配下のコンポーネント全て

## 副作用と useEffect

React における`副作用`とは、関数コンポーネントの出力に関係ない処理のことであり、`useEffect` はこの副作用を実行するための Hook になります。

useEffect を用いることでレンダリングと副作用を切り離し、`レンダリングの後まで実行タイミングを遅らせる`ことができます。

## useEffect の使い方

第1引数には実行させたい副作用関数を、第2引数には副作用関数の実行タイミングを制御する依存データの配列を記述します。

第2引数を指定することにより、第1引数に渡された副作用関数の実行タイミングを制御することができます。React は第2引数の依存配列の中身の値を比較して、副作用関数をスキップするかどうかを判断します。

return ではクリーンアップしたい処理を指定します。(なければ return ブロックは不要)

```typescript
useEffect(
  // 副作用関数
  () => {
    console.log('副作用関数が実行されました')
    return () => {
      // clean up処理を記述する
      console.log('クリーンアップします。')
    }
  },
  // 依存データの配列
  [依存する変数の配列]
)

// 実際にはこのような形で書く
useEffect(() => {
  console.log('副作用関数が実行されました')
  return () => {
    console.log('クリーンアップします。')
  }
}, [])
```

| | 説明 | データ型 |
| --- | --- | --- |
| 第1引数 | 副作用関数（戻り値はクリーンアップ関数、または何も返さない） | 関数 |
| 第2引数 | 副作用関数の実行タイミングを制御する依存データが入る（省略可能） | 配列 |

### クリーンアップとは？

クリーンアップとは、不要となったリソースなどを解放することです。クリーンアップ関数を return すると、2度目以降のレンダリング時に前回の副作用を消してしまうことができます。

クリーアンアップ処理は以下のような処理が記述されます。

- イベントリスナーの解除
- タイマー処理のキャンセル
- DBアクセス後の接続解放

## useEffect を使う状況

主に以下の3パターンが考えられます。

1. レンダリングされたタイミングで処理を実行する
2. 初回レンダリング時のみ処理を実行する
3. 特定の　State　の更新による再レンダリングのタイミングで処理を実行する

### 1. レンダリングされたタイミングで処理を実行する

**第2引数には何も指定しません。**

このように記述した場合はレンダリングされるたびに副作用関数が実行されます。

```typescript
useEffect(() => {
  console.log('レンダーされました。')
  return () => {
    console.log('クリーンアップします。')
  }
})
```

### 2. 初回レンダリング時のみ処理を実行する

**第2引数に `[]` を指定します。**

このようにした場合は初回のレンダリング時のみ副作用関数が実行されます。

```typescript
useEffect(() => {
  console.log('レンダーされました。')
  return () => {
    // clean up処理を記述する。
    console.log('クリーンアップします。')
  }
}, [])
```

### 3. 特定の　State　の更新による再レンダリングのタイミングで処理を実行する

**第2引数に `[state]` を指定します。**

配列に指定した state が更新（再レンダリング）されたときに副作用関数が実行されます。もちろんですが、初回のレンダリングでは State は初期値に更新されますので、初回も副作用関数は実行されます。

```typescript
useEffect(() => {
  console.log('レンダーされました。')
  return () => {
    console.log('クリーンアップします。')
  }
}, [state])
```

## 参考サイト

↓React のレンダリングについて超絶詳しく書かれている記事で、グローバルな State を使用した時まで場合体系的に知ることができます。
[Reactのレンダリングに関する完全ガイド](https://qiita.com/hellokenta/items/6b795501a0a8921bb6b5)
